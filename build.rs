use serde::Deserialize;
use std::env;
use std::fs;
use std::path::Path;

#[derive(Deserialize)]
struct NavConfig {
    groups: Vec<NavGroup>,
}

#[derive(Deserialize)]
struct NavGroup {
    pages: Vec<String>,
}

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let nav_path = "docs/_nav.json";
    println!("cargo:rerun-if-changed={nav_path}");

    let json = fs::read_to_string(nav_path).expect("Failed to read docs/_nav.json");
    let nav: NavConfig = serde_json::from_str(&json).expect("Failed to parse docs/_nav.json");

    let mut code = String::from("// Auto-generated by build.rs â€” do not edit\n{\n");
    code.push_str("    let mut map = std::collections::HashMap::new();\n");

    for group in &nav.groups {
        for page in &group.pages {
            let mdx_path = format!("docs/{page}.mdx");
            println!("cargo:rerun-if-changed={mdx_path}");

            // Use absolute path so include_str! works from OUT_DIR
            let abs_path = format!("{manifest_dir}/{mdx_path}");
            code.push_str(&format!(
                "    map.insert(\"{page}\", include_str!(\"{abs_path}\"));\n"
            ));
        }
    }

    code.push_str("    map\n}\n");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("doc_content_generated.rs");
    fs::write(&dest, code).expect("Failed to write generated file");
}
