use serde::Deserialize;
use std::env;
use std::fs;
use std::path::Path;

#[derive(Deserialize)]
struct NavConfig {
    groups: Vec<NavGroup>,
}

#[derive(Deserialize)]
struct NavGroup {
    pages: Vec<String>,
}

/// Generates `doc_content_generated.rs` in `OUT_DIR` from a `_nav.json` file.
///
/// Call this from your `build.rs`:
///
/// ```rust,ignore
/// fn main() {
///     dioxus_docs_kit_build::generate_content_map("docs/_nav.json");
/// }
/// ```
///
/// The generated file is an expression that returns a `HashMap<&'static str, &'static str>`
/// and is intended to be used with `include!()`.
///
/// The docs directory is inferred from the parent of `nav_json_path`
/// (e.g. `"docs/_nav.json"` → `"docs"`).
pub fn generate_content_map(nav_json_path: &str) {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    println!("cargo:rerun-if-changed={nav_json_path}");

    let json = fs::read_to_string(nav_json_path)
        .unwrap_or_else(|e| panic!("Failed to read {nav_json_path}: {e}"));
    let nav: NavConfig = serde_json::from_str(&json)
        .unwrap_or_else(|e| panic!("Failed to parse {nav_json_path}: {e}"));

    // Infer docs directory from nav path parent (e.g. "docs/_nav.json" → "docs")
    let docs_dir = Path::new(nav_json_path)
        .parent()
        .and_then(|p| p.to_str())
        .unwrap_or("docs");

    let mut code = String::from("// Auto-generated by dioxus-docs-kit-build — do not edit\n{\n");
    code.push_str("    let mut map = std::collections::HashMap::new();\n");

    for group in &nav.groups {
        for page in &group.pages {
            let mdx_path = format!("{docs_dir}/{page}.mdx");
            let full_path = format!("{manifest_dir}/{mdx_path}");

            if !Path::new(&full_path).exists() {
                println!(
                    "cargo:warning=Skipping \"{page}\": {mdx_path} not found (OpenAPI endpoints don't need .mdx files)"
                );
                continue;
            }

            println!("cargo:rerun-if-changed={mdx_path}");

            // Use absolute path so include_str! works from OUT_DIR
            code.push_str(&format!(
                "    map.insert(\"{page}\", include_str!(\"{full_path}\"));\n"
            ));
        }
    }

    code.push_str("    map\n}\n");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("doc_content_generated.rs");
    fs::write(&dest, code).expect("Failed to write generated file");
}
